#!/usr/bin/env Rscript

## Script Info: This program takes scanned QR codes from samples in a 96-well plate and matches well information
	# with relevant metadata, and also draws a pdf map of the plate if desired.

## set up environment
	suppressPackageStartupMessages(require(optparse))
## parse arguments
	option_list <- list(
		make_option(c("-i", "--input"),    action="store",       default=NA,      type='character', help="Input csv file of query barcodes, as generated by APPNAME. REQUIRED."), 
		make_option(c("-m", "--metadata"), action="store",       default=NA,      type='character', help="Input metadata file. Must have SampleID and SampleBarcode cols. REQUIRED."),
		make_option(c("-o", "--output"),   action="store",       default="AUTO",  type='character', help="Output csv file path (should end in .csv, default=AUTO")
	) 
	opt = parse_args(OptionParser(option_list=option_list))

	
	
## set up output file paths for "AUTO" condition
	rm_extension <- function(fp){
		fp <- unlist(strsplit(fp, ""))
		suffixlength <- min(length(fp) - which(fp == "."))
		if(suffixlength <= 4){ fp <- fp[1:(length(fp) - suffixlength - 1)] }
		return(paste(fp, collapse=""))
	}
	if(opt$output == "AUTO"){ opt$output <- paste(rm_extension(opt$input), ".mapping.csv", sep="") }
	if(opt$pdfout == "AUTO"){ opt$pdfout <- paste(rm_extension(opt$input), ".pdfmap.pdf", sep="") }

	
## read in inputs
	scanned_barcodes <- read.table(opt$input, sep=",", comment.char="", header=T, colClasses="character", quote="\"")
	metadata <- read.table(opt$metadata, sep=",", comment.char="", header=T, colClasses="character", quote="\"")

	
	
## are barcodes in metadata unique (at least for the ones we want)?
	bc_sums <- sapply(X=scanned_barcodes$Barcode, FUN=function(x){sum(metadata$SampleBarcode==x)})
	bc_error <- FALSE
	if( all(bc_sums == 1)){
		message("✓ All query barcodes present exactly once in metadata.")
	}else{
		# find errors and report them
		bc_error <- TRUE
		if(any(bc_sums < 1)){
			message("✘ CRITICAL ERROR: Not all barcodes are present in metadata.")
			bad_bcs1 <- scanned_barcodes$Barcode[which(bc_sums < 1)]
			message( paste("  Offending barcodes:", paste(bad_bcs1, collapse=", ")) )
		}
		if(any(bc_sums > 1)){
			stop("✘ CRITICAL ERROR: Query barcodes match multiple metadata entries.")
			bad_bcs2 <- scanned_barcodes$Barcode[which(bc_sums > 1)]
			message( paste("  Offending barcodes:", paste(bad_bcs2, collapse=", ")) )
		}
	}

## check whether barcodes are sorted by date, old -> new
	if(all(order(scanned_barcodes$Date) == 1:nrow(scanned_barcodes))){
		message("✓ Barcodes file was sorted old-to-new.")
	}else{
		message("✘ Barcodes file NOT sorted by date. This is bad unless you did it on purpose.")
	}

## for every sample id in the barcodes file, pull out some data
	scanned_barcodes_metadata <- metadata[ sapply(X=scanned_barcodes$Barcode,
	                                              FUN=function(x)  {
	                                                which(metadata$SampleBarcode==x)
	                                                }),]

## come up with some well names (rows and cols) for all the barcode stuff
	# this is 100% contingent on them being scanned from upper right to lower left
	#A-H, THEN 1:12
	WellRow <- rep(LETTERS[1:8], 12)
	WellCol <- rep(1:12, each=8)
	# pad WellCol so there's a leading zero on single digit integers e.g. A01 vs A1
	WellCol   <- formatC(WellCol, width = 2, format = "d", flag = "0")
	WellCombo <- paste(WellRow, WellCol, sep = "")
	
	# throw it all into a data frame
	wells_df <- data.frame(WellRow, WellCol, WellCombo)[ 1:nrow(scanned_barcodes_metadata) ,]
	

## do first output: table of barcode stuff and metadata
	write.table(mapping_output, file=opt$output, sep=",", row.names=F)

## composite mapping table for QuantStudio pcr
  # generate colors for each unique sample type
	sample_data_frame <- as.data.frame(mapping_output$Sample_Type)
	colnames(sample_data_frame) <- "samps"
	samps <- unique(mapping_output$Sample_Type)
	colrs_frame <- as.data.frame(t(col2rgb((sample(rainbow(length(samps)),size = length(samps))))))
  colrs<-paste('"', "RGB(",colrs_frame$red, ",", colrs_frame$green, ",", colrs_frame$blue, ")", '"', sep = "")
	
	colorcode<-data.frame(samps,colrs)
	#merge assigned colors with all 96 samples
	colorcode <- merge(sample_data_frame, colorcode, by.x = "samps", sort = F)
	
	# create empty matrix with appropriate column names
	qpcr_output <- matrix("", nrow=nrow(mapping_output), ncol = 11)
	qpcr_output <- as.data.frame(qpcr_output, stringsAsFactors=F)
	# fill in columns with appropriate data
	well_ass <-paste(rep(LETTERS[1:8],12),rep(1:12,each=8),sep = "")
	well_ass <-well_ass[1:nrow(mapping_output)]
	
	qpcr_output[1] <- 1:nrow(mapping_output)
	qpcr_output[2] <- well_ass
	qpcr_output[3] <- mapping_output$SampleID
	qpcr_output[4] <- mapping_output$Sample_Type
	qpcr_output[5] <- colorcode$colrs
	qpcr_output[6] <- rep("BarcodeAmp", nrow(mapping_output))
	qpcr_output[7] <- rep('"RGB(255,160,122)"', nrow(mapping_output))
	qpcr_output[8] <- rep("UNKNOWN", nrow(mapping_output))
	qpcr_output[9] <- rep("SYBR", nrow(mapping_output))
	  
	colnames(qpcr_output) <- c("Well","Well Position","Well Comments",
	                           "Sample Name",	"Sample Color",	"Target Name",
	                            "Target Color",	"Task",	"Reporter",	"Quencher",	"Quantity")

	write("[Sample Setup]",file = paste(rm_extension(opt$input), ".qpcr_output.csv", sep=""),sep = "")
	write.table(qpcr_output, file = paste(rm_extension(opt$input), ".qpcr_output.csv", sep=""),sep="," ,row.names = F, quote = F, append = T)

		## write out the sampleIDs in 96 well format to a csv
	
		# set row counter to 1
	  mdrow <- 1
		# paste sample id and sample type together
		unwrapped_sampleids <-paste(mapping_output$SampleID, mapping_output$Sample_Type)
		
		# loop through all samples starting a new row
		 for(j in 1:12)
		   {
		    for(i in 1:8)
		    {
		    sampids_mat_unwrapped[i,j] <- unwrapped_sampleids[mdrow]
		    mdrow <- mdrow + 1
		    if(mdrow > length(unwrapped_sampleids)){break()}  
		 }
		colnames(sampids_mat_unwrapped) <- rep(1,12) 
		   }
		#Write csv of unwrapped sample names in plate format
		write.table(sampids_mat_unwrapped, paste(rm_extension(opt$input), ".plainplatemap.csv", sep=""), col.names=F, row.names=F, sep = "," )
	




